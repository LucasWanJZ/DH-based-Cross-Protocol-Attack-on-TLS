from cypari2 import Pari

def mod_inverse(a, b):
    # Extended Euclidean Algorithm to find the modular inverse
    original_b = b
    x0, x1 = 0, 1
    while a > 1:
        q = a // b
        a, b = b, a % b
        x0, x1 = x1 - q * x0, x0
    
    if x1 < 0:
        x1 += original_b
    
    return x1

# Initialize Pari
pari = Pari()

# Constants
Primes = [518177537, 518177551, 518177593, 518177599, 518177609, 518177641, 518177651, 518177689, 518177717, 518177729, 518177749, 518177761, 518177813, 518177857, 518177903, 518177917, 518177923, 518177929, 518177987, 518177999, 518178019, 518178041, 518178053, 518178091, 518178107, 518178169, 518178181, 518178211, 518178217, 518178233, 518178257, 518178263, 518178281, 518178307, 518178313, 518178319, 518178341, 518178373, 518178407, 518178421, 518178433, 518178439, 518178443, 518178449, 518178457, 518178481, 518178497, 518178511, 518178571, 518178587, 518178593, 518178611, 518178629, 518178667, 518178709, 518178761, 518178779, 518178809, 518178833, 518178839, 518178841, 518178883, 518178953, 518178959, 518178961, 518178967, 518178977, 518178979, 518179003, 518179027, 518179037, 518179061, 518179097, 518179099, 518179127, 518179199, 518179219, 518179231, 518179243, 518179303, 518179309, 518179349, 518179373, 518179391]
public = int("B862D7EB18D3DC2F697C9BC3D605A16B9B66B61B5085DC44897D88AEA4FFF788673B26D6FE2A41E74006EA37D8AB0A19842038FEC6C6223AE5F36D7FE07E9DEFCE8DBECAC36C11443DAEE22A15D2B3AA7FB6F47D7120AE560575C72EBF8FB096E233F20893E8BD0033E79A27D62FB8ED2663D2F70ECED7627B3A8C847BFAD32AA951B3ED2C012DAB52E416B6B6BC0734198C2235985676B96FA4737FBAB89EB9DF392A39C804AE0D5E7F01B0E512C32D9BAA842D412D550C30120856D99DB74B1A22A89BC33BEA5E74FA33EB3340F3F5215CC5D5A718142FCB1B4459615E2E1B84CC7C99E639DD53E1F9D1C76EA340AF8246648E4389C039F15029788E440446CE852EAFAE99A258BBC8898A0A7C1785031A552B2769B4035AAA648636544EB70FC5FD5981024ABCB3A8B61F08E4F235",16)
real_private = int("7D70EB539F1AB25CA6639264D710837A3D3B668B5D9372756B647E96394A68EFE4349D265965CEDE44272E33043DC959D1C903EC8F29213AC49C51EC1BAAFF283D6FD3F93BC3C5868C03C36FE97C81EC3B583E5534DF2BA12BF67429405B4365AECFA67A41B83A300C2AD1FEA639480F9816C97D5E4E24A1F103AC78A02D8D2E59EF4FD5576EE7C5AE2C822BA08AAC4B8B1F18243492340DA35F54627CBF4EB274090117A747F41D27D1A1E623B0F26D713BDBE188A3816EA021EE358DBFE21FC560709CE922928EEC29E74792626F64276BAC9F885B6E2A02A6E68F15A47D05C8E3F064891D8F38D7376EE7A426B3A03DBC395FB214ADB81EA899963FC4E7E29A6BB5CF85399ECD92B870EFF6C8BA8DAA97D0002B35EDA87433D6D156539C4FBD57AE051A7B79742B23DEA7247A4031",16)
base = int("1f9609b6473a4fb0a14627856351e1038ad367459a4c406f421ab94ea597ce812046264b9371451dce6969d40b45e7bf4ca3f9757ddf6e4069e616cd2721e40b63958e722e85788ed1d65ff0450b0ba3c31214555877", 16)

# Lists to store results
res = []
m = []
N = []

# Compute the product of all primes
n = 1
for p in Primes:
    n *= p


# Compute results using Chinese Remainder Theorem
for p in Primes:
    y = pari.Mod(public, p)
    g = pari.Mod(base, p)
    res_i = pari.znlog(y,g)
    res.append(int(res_i))  
    m_i = n // p
    m.append(int(m_i))
    N_i = mod_inverse(int(m_i), p)
    N.append(int(N_i))


print("CRT results:")  
# Compute x using the CRT
x = pari(0)
for i in range(len(Primes)):
    x += (res[i] * m[i] * N[i])%n

x = int(x % n)

# Verify the calculated private key
print("Public =", public)
print("n =", n)
print("Base =", base)
print("parilog =", pari.znlog(pari.Mod(public, n), pari.Mod(base, n)))
print("Calculated private key using CRT:")
print(x)
print("Actual Private key:")
print(real_private)
